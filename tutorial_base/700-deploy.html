<!DOCTYPE html>
<html lang="en" ng-app="jpm">

	<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="/css/style.css" rel="stylesheet" />
<title>Creating an Application</title>


</head>


<body>

	<ul class="container12 menu-bar">
	<li span=10><a class=menu-link href="/"><img class=menu-logo
			src='/img/EnRouteIcon_CMYK.png'></a> <a
		href="/book/100-introduction.html">Guide </a><a
		href="/book/400-services.html">Services </a><a
		href="/book/700-links.html">Links </a><a
		href="/forum.html">Forum</a>
	<li class=menu-link span=1>
	<li class=menu-link span=1><b>BETA</b>
	
</ul>


					

	<ul class=container12>
		<li span=3>
			<div>
			<ul class="side-nav">
	
		
			<li><a href="/book/100-introduction.html">Guide</a>
	  	
  	
		
			<li><a href="/book/200-quick-start.html">Quick Start Tutorial</a>
	  	
  	
		
			<li><a href="/book/210-overview.html">Overview</a>
	  	
  	
		
			<li><a href="/book/215-sos.html">Building Service Oriented Systems</a>
	  	
  	
		
			<li><a href="/book/220-tutorial-base.html">Base Tutorial</a>
	  	
  	
		
			<li><a href="/book/300-principles.html">Principles</a>
	  	
  	
		
			<li><a href="/book/400-services.html">Service Catalog</a>
	  	
  	
		
			<li><a href="/book/700-links.html">Where to Find Stuff</a>
	  	
  	
</ul>

			</div>
			
		<li span=9>
			<div>
				<a class=nav-prev href="600-testing.html" >Prev</a>
				<a class=nav-next href="800-ci.html" >Next</a> 
				<br/>
				<hr/>
				<h1> Creating an Application</h1>
				<div class=tutorial-content>
				<h2 id="what-you-will-learn-in-this-section">What You Will Learn in This Section</h2>

<p>All this work to get a working provider! However, we’ve only run it in a evaluation and test mode. In this section we will take a look how we can use this provider bundle in an application we can deploy.</p>

<p>There are a myriad of deploy formats in Java (and OSGi!): WAR files, Karaf CARs, EAR files, OSGi Subsystems, OSGi Deployment Admin, etc. Bndtools can support all of those through <em>plugins</em> but always natively supports the most humblest of all deployment formats: an executable JAR. An executable JAR has no external dependencies, everything it needs outside the JDK is embedded.</p>

<p>The beauty of An executable JAR is that it can be started anywhere there is a java virtual machine:</p>

<pre><code>$ java -jar executable.jar
</code></pre>

<h2 id="creating-an-application">Creating an Application</h2>

<p>The first thing we need to do is create a <code>bndrun</code> file. A <code>bndrun</code> file is a separate file for the <code>bnd.bnd</code> <code>Run</code> tab. It allows us to specify a runtime for our framework. </p>

<p>So do a <code>New/Bndtools OSGi Project</code> and use <code>com.acme.prime.eval.application</code> as the project name. The <code>.application</code> extension for this project creates an <em>application</em> project. Don’t forget to use the OSGi enRoute templates! An application project should contain no code (or very little) but acts as a spear point. It contains the requirements that will drive the final application.</p>

<h2 id="the-sole-content">The Sole Content</h2>

<p>By default, an application only contains a Gogo shell command, in this case in the <code>EvalApplication</code> class. This one is very similar and then not really to the <code>EvalImpl</code> class. In the <code>EvalImpl</code> class we just made the existing API call, <code>eval</code>, available as a Gogo command. In this application project we need to get the service and call the method on that service. Getting a service is made very easy with DS, just add a setter method and add the <code>@Reference</code> annotation. So lets replace the code for  the <code>EvalApplication</code> code with:</p>

<pre><code>@Component(
	service=EvalApplication.class, 
	property = { 
		Debug.COMMAND_SCOPE + "=eval",
		Debug.COMMAND_FUNCTION + "=eval" 
	},
	name="com.acme.prime.eval"
)
public class EvalApplication {
	private Eval eval;

	public double eval(String m) throws Exception {
		return eval.eval(m);
	}
	
	@Reference
	void setEval( Eval eval) {
		this.eval= eval;
	}
}
</code></pre>

<p>This code registers a dummy service that now provides the <code>eval:eval</code> command to Gogo shell (notice the imaginative difference between the <code>test:eval</code> command we created in the provider.</p>

<p>Just like the test project, we need to add a dependency on the API project. As usual, go to the <code>Build</code> tab and add the <code>com.acme.prime.eval.api</code> project.</p>

<h2 id="defining-the-application">Defining the Application</h2>

<p>We will define the run time requirements in a special file, a <code>bndrun</code> file. Such a file is already placed in the application project: <code>com.acme.prime.eval.bndrun</code>. Such a <code>bndrun</code> file is basically the information we have been working with in the <code>bnd.bnd</code> <code>Run</code> tab. If you double click on it, then it should look like:</p>

<p><img src="/img/tutorial_base/deploy-bndrun-0.png" alt="Application bndrun" /></p>

<p>As you can see, the initial requirement for our Gogo command is already there. Before we try it out, let’s add a shell (<code>org.apache.felix.gogo.shell</code>) so it is slightly more interactive. That’s it! Hit the <code>Resolve</code> button and save the <code>bndrun</code> file. </p>

<p><img src="/img/tutorial_base/deploy-bndrun-1.png" alt="Application bndrun" /></p>

<p>At the right top of the <code>bndrun</code>’s <code>Run</code> tab there are a number of buttons:</p>

<p><img src="/img/tutorial_base/deploy-bndrun-2.png" alt="Application bndrun" /></p>

<p>If you click the <code>Debug OSGi</code> button then bnd will launch a framework and run your application.</p>

<p>Since we have a shell, we can try out the command:</p>

<pre><code>g! eval:eval pi*13.36901521971921
42.0
</code></pre>

<p>And it took considerably less time than 7.5 million years!</p>

<h2 id="debugging">Debugging</h2>

<p>Let’s first kill this framework so we can start another framework that is friendlier on the debugging side. Just click on the red button in the Eclipse console.</p>

<p>The application project also includes a <code>debug.bndrun</code> file. This is also a <code>bndrun</code> file but it adds debug requirements. So quit the running framework (Go to the console, and click on the red button) and double click the <code>debug.bndrun</code> file, resolve, and click <code>Debug OSGi</code>.</p>

<p>The first thing you’ll notice is how the console is filled with red text. This is the trace output of the launcher. If things do not really work as you expected (never happens to us …) then this output, which traces the installation process in fine detail, can help you solve the problems. This behavior is triggered by the -runtrace flag. Click on the <code>bnd.bnd</code> <code>Source</code> tab, and change it to false or remove it if you do not want this trace.</p>

<p><img src="/img/tutorial_base/deploy-debug-0.png" alt="Application bndrun" /></p>

<p>The <code>debug.bndrun</code> file inherits from the <code>com.acme.prime.eval.bndrun</code> file, any initial requirement we add to this file is automatically added to the debug run; first principle of Do Not Repeat Yourself (DNRY). However, the <code>debug.bndrun</code> adds a set of standard requirements that make it so much easier to debug OSGi applications. It adds Web Console, the Gogo shell, etc. So click on the <code>Debug OSGi</code> button and then go to <a href="http://localhost:8080/system/console/xray">http://localhost:8080/system/console/xray</a> to inspect your OSGi system. The user id and password were <code>admin</code>, and … drums … <code>admin</code>.</p>

<p><img src="/img/tutorial_base/deploy-debug-1.png" alt="Application bndrun" /></p>

<p>XRay and its associated tools were explained in the <a href="450-debug.html">debug section</a>.</p>

<h2 id="exporting">Exporting</h2>

<p>This was fun, ok, at least not bad. But how do we deploy this? How do we get this running on our target environment? Well, we can make this into an application, an executable JAR file. </p>

<p>We start by double clicking the <code>com.acme.prime.eval.bndrun</code> file and selecting the <code>Run</code> tab. Remember where we found the <code>Debug OSGi</code> button, on the right top of the <code>bndrun</code> <code>Run</code> tab. A little bit more to the right you find an <code>Export</code> button. </p>

<p><img src="/img/tutorial_base/deploy-bndrun-2.png" alt="Application bndrun" /></p>

<p>Clicking the <code>Export</code> button shows you a dialog that asks you where to store the exeecutable JAR on the file system:</p>

<p><img src="/img/tutorial_base/deploy-export-1.png" alt="Application bndrun" /></p>

<p>Select the <code>Executable JAR</code>, and save this on your desktop under the name <code>com.acme.prime.jar</code>. </p>

<p><img src="/img/tutorial_base/deploy-export-2.png" alt="Application bndrun" /></p>

<p>This JAR is quite wondrous: it has no external dependencies. To execute it, you should open a shell on your desktop:</p>

<pre class="shell"><code>$ java -version
java version "1.8.0"
Java(TM) SE Runtime Environment (build 1.8.0-xxx)
Java HotSpot(TM) 64-Bit Server VM (build xxxx, mixed mode)

$ java -jar com.acme.prime.jar
____________________________
Welcome to Apache Felix Gogo	
g! eval:eval 3+4+5+6+7+8+9
42.0
</code></pre>

<p>Isn’t there more in the universe? It does makes you wonder that so many sums have this answer?</p>

<p>Anyway, when you had enough math you can quit this app by hitting control-c.</p>

<h2 id="how-does-it-work">How Does it Work?</h2>

<p><code>bndrun</code> files define the requirements on a desired runtime. When the <code>Resolve</code> button is hit, the bnd <em>resolver</em> looks at the initial requirements and will try to find resources in the repositories that together match those requirements and the requirements from the introduced resources. The resulting set of bundles defines a runtime, these bundles are set in the <code>-runbundles</code> instruction.</p>

<p>A runtime environment can then executed to verify it, potentially resulting in some modifications. If the result is ok, then the export function of bnd is used.</p>

<p>The bnd export goes through a plugin; this is the same plugin that manages the launching. In this case this is the default <code>aQute.launch</code> plugin. The plugin takes the runtime environment and creates a JAR that contains all the dependencies, including itself and any properties; creating a JAR that is completely self contained.</p>

				</div>
				<hr/>
				<a class=nav-prev href="600-testing.html" >Prev</a>
				<a class=nav-next href="800-ci.html" >Next</a> 

			</div>
	</ul>

	
<nav class=next-prev>
	<a href=''></a> <a href='800-ci.html'></a>
</nav>
<footer class="container12" style="border-top: 1px solid black;padding:10px 0">
	<ul span=12 row>
		<li span=3>
			<ul>
				<li><a href="/contact.html">Contact</a>
			</ul>
		<li span=3>
			<ul>
				<li><a href="">Developers</a>
			</ul>
		<li span=4>
			<ul>
				<li><a href="">More</a>
			</ul>
		<li span=2>
			<a href="http://www.osgi.org"><img style="float:right;width:8em" src="/img/osgi-logo-256.png"></a>
	</ul>
</footer>

</body>
</html>
